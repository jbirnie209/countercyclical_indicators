<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Economic Indicators — FRED Charts</title>

<noscript>
  <div style="padding:12px;background:#ffe5e5;color:#900;border:1px solid #f99;border-radius:8px;margin:12px 0;">
    This page needs JavaScript enabled. Please enable JS and reload.
  </div>
</noscript>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.3/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>

<style>
  :root { color-scheme: light dark; }
  * { box-sizing: border-box; }
  body {
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    margin: 0; padding: 16px; line-height: 1.45;
    background: Canvas; color: CanvasText;
  }
  header { display: flex; flex-wrap: wrap; align-items: center; gap: 12px; margin-bottom: 10px; }
  h1 { font-size: 1.25rem; margin: 0 8px 0 0; font-weight: 600; }
  .hint { font-size: .9rem; opacity: .8; }
  .controls { margin-left: auto; display: flex; gap: 8px; align-items: center; }
  input[type="text"] {
    padding: 8px 10px; border: 1px solid #ccc;
    border-radius: 10px; background: Canvas; color: CanvasText; min-width: 260px;
  }
  button {
    padding: 8px 12px; border: 1px solid #ccc; border-radius: 10px; cursor: pointer;
    background: rgba(127,127,127,.08); color: CanvasText;
  }
  button:hover { background: rgba(127,127,127,.14); }
  .grid { display: grid; grid-template-columns: 1fr; gap: 16px; margin-top: 12px; }
  @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }
  .card {
    border: 1px solid #ddd;
    border-radius: 14px; padding: 12px; background: Canvas;
    box-shadow: 0 1px 6px rgba(0,0,0,.08);
  }
  .card h2 { margin: 0 0 8px 4px; font-size: 1rem; font-weight: 600; }
  canvas { width: 100%; height: 340px; }
  footer { margin-top: 12px; font-size: .85rem; opacity: .75; }
  .err { color: #b00020; font-weight: 600; }
  .legend-note { font-size: .85rem; opacity: .8; margin: 4px 0 0 6px; }
</style>
</head>
<body>
<header>
  <h1>Economic Indicators — FRED</h1>
  <div class="hint">Last 10 years visible. Median is trailing 10-year rolling.</div>
  <div class="controls">
    <input id="apiKey" type="text" placeholder="240c75e56610e9e1b96c402b2b779d2d" />
    <button id="saveKeyBtn" title="Store your key in this browser only">Save key</button>
    <button id="refreshBtn">Refresh</button>
  </div>
</header>

<div id="status" class="hint"></div>
<div id="clickTest" class="hint" style="opacity:.75;margin:4px 0 10px 0;"></div>

<div class="grid">
  <section class="card">
    <h2>ICE BofA US High Yield Spread (BAMLH0A0HYM2)</h2>
    <div class="legend-note">Line = series; Dashed = trailing 10-year median</div>
    <canvas id="chartHY"></canvas>
  </section>

  <section class="card">
    <h2>10y – 1y Treasury Yield (DGS10 − DGS1)</h2>
    <div class="legend-note">Computed daily from FRED; dashed = trailing 10-year median</div>
    <canvas id="chartSlope"></canvas>
  </section>

  <section class="card">
    <h2>10-Year TIPS Yield (DFII10)</h2>
    <div class="legend-note">Investment basis (inflation-indexed); dashed = trailing 10-year median</div>
    <canvas id="chartTIPS"></canvas>
  </section>
</div>

<footer>
  Sources: St. Louis Fed (FRED). Data shown with 2-decimal formatting.
</footer>

<script>
/* Sanity: prove buttons are wired */
document.getElementById('saveKeyBtn').addEventListener('click', () => {
  document.getElementById('clickTest').textContent = 'Save clicked ✓';
});
document.getElementById('refreshBtn').addEventListener('click', () => {
  document.getElementById('clickTest').textContent = 'Refresh clicked ✓';
});

/* ========= BASIC CONFIG ========= */
const SERIES = {
  HY:   { id: 'BAMLH0A0HYM2',  name: 'HY Spread' },
  D10:  { id: 'DGS10',         name: '10Y' },
  D1:   { id: 'DGS1',          name: '1Y'  },
  TIPS: { id: 'DFII10',        name: '10Y TIPS' }
};
const YEARS_TO_SHOW = 10, YEARS_TO_FETCH = 20;
const FRED_BASE = 'https://api.stlouisfed.org/fred/series/observations';
const FREQ = 'd', FILE_TYPE = 'json';

const apiInput = document.getElementById('apiKey');
apiInput.value = localStorage.getItem('fred_api_key') || ''; // optional default
document.getElementById('saveKeyBtn').addEventListener('click', () => {
  localStorage.setItem('fred_api_key', apiInput.value.trim());
  toast('API key saved in this browser.');
});
document.getElementById('refreshBtn').addEventListener('click', () => bootstrap(true));

const statusEl = document.getElementById('status');
function setStatus(msg, isError=false){ statusEl.innerHTML = isError ? ('<span class="err">'+msg+'</span>') : msg; }
function toast(msg){ setStatus(msg); setTimeout(()=> setStatus(''), 2200); }
function fmt2(x){ return (x==null||Number.isNaN(x)) ? '' : Number(x).toFixed(2); }
function dateMinusYears(d, years){ const dd=new Date(d); dd.setFullYear(dd.getFullYear()-years); return dd; }
function iso(date){ return date.toISOString().slice(0,10); }
const today = new Date();
const fetchStart = iso(dateMinusYears(today, YEARS_TO_FETCH));
const showStart  = iso(dateMinusYears(today, YEARS_TO_SHOW));

/* ========= WEB WORKER ========= */
const workerSrc = `
  self.onmessage = (e) => {
    const { series, windowYears } = e.data;
    const MS_PER_YEAR = 365.25 * 24 * 3600 * 1000;
    const medians = new Array(series.length).fill(null);
    let startIdx = 0;
    function medianOf(arr){
      if (!arr.length) return null;
      const a = arr.slice().sort((x,y)=>x-y);
      const mid = Math.floor(a.length/2);
      return (a.length % 2) ? a[mid] : (a[mid-1] + a[mid]) / 2;
    }
    for (let i=0; i<series.length; i++){
      const t = series[i].t;
      const cutoff = t - windowYears * MS_PER_YEAR;
      while (startIdx < i && series[startIdx].t < cutoff) startIdx++;
      const windowVals = [];
      for (let k=startIdx; k<=i; k++) {
        const val = series[k].v;
        if (val != null && !Number.isNaN(val)) windowVals.push(val);
      }
      medians[i] = medianOf(windowVals);
    }
    self.postMessage({ medians });
  };
`;
const workerURL = URL.createObjectURL(new Blob([workerSrc], {type: 'text/javascript'}));

/* ========= FETCH ========= */
async function fredFetch(seriesId, apiKey){
  const url = new URL(FRED_BASE);
  url.searchParams.set('series_id', seriesId);
  url.searchParams.set('api_key', apiKey);
  url.searchParams.set('file_type', FILE_TYPE);
  url.searchParams.set('observation_start', fetchStart);
  url.searchParams.set('observation_end', iso(today));
  url.searchParams.set('frequency', FREQ);

  let resp;
  try { resp = await fetch(url.toString(), { cache: 'no-store' }); }
  catch (netErr) { throw new Error(\`Network error calling FRED for \${seriesId}: \${netErr?.message || netErr}\`); }
  if (!resp.ok) throw new Error(\`FRED \${seriesId} HTTP \${resp.status} \${resp.statusText}\`);

  let data;
  try { data = await resp.json(); }
  catch (parseErr) { throw new Error(\`Could not parse JSON for \${seriesId}: \${parseErr?.message || parseErr}\`); }

  if (!data || !Array.isArray(data.observations)) throw new Error(\`Unexpected FRED response for \${seriesId}: missing observations\`);

  const out = data.observations.map(o => {
    const v = (o.value === "." ? null : Number(o.value));
    return { t: new Date(o.date).getTime(), v, d: o.date };
  }).filter(pt => !Number.isNaN(pt.t));

  if (out.length === 0) throw new Error(\`FRED returned 0 rows for \${seriesId} (check API key and parameters)\`);
  return out;
}
function joinAndDiff(a, b){
  const mapB = new Map(b.map(x => [x.d, x]));
  const out = [];
  for (const x of a){
    const y = mapB.get(x.d);
    if (!y) continue;
    if (x.v == null || y.v == null) continue;
    out.push({ t: x.t, d: x.d, v: x.v - y.v });
  }
  return out;
}
function filterShowWindow(arr){
  const minMs = new Date(showStart).getTime();
  return arr.filter(p => p.t >= minMs);
}

/* ========= CHARTS ========= */
function makeChart(ctx, label){
  return new Chart(ctx, {
    type: 'line',
    data: { datasets: [
      { label, data: [], parsing: false, borderWidth: 2, pointRadius: 0 },
      { label: 'Trailing 10y Median', data: [], parsing: false, borderWidth: 2, pointRadius: 0, borderDash: [6,6] }
    ]},
    options: {
      responsive: true, maintainAspectRatio: false, animation: false,
      interaction: { mode: 'nearest', intersect: false },
      plugins: { legend: { position: 'top' },
        tooltip: { callbacks: { label: (ctx) => `${ctx.dataset.label}: ${fmt2(ctx.parsed.y)}` } } },
      scales: {
        x: { type: 'time', time: { unit: 'year' }, ticks: { maxRotation: 0, autoSkip: true },
             min: new Date(showStart).getTime(), max: new Date().getTime() },
        y: { ticks: { callback: (v) => fmt2(v) } }
      }
    }
  });
}

/* ========= MAIN ========= */
let charts = null;
async function bootstrap(isRefresh=false){
  try{
    const apiKey = (apiInput.value || '').trim();
    if (!apiKey){ setStatus('Enter your FRED API key, then press Save key and Refresh.', true); return; }
    setStatus(isRefresh ? 'Refreshing…' : 'Loading data…');

    const [hyRaw, d10Raw, d1Raw, tipsRaw] = await Promise.all([
      fredFetch(SERIES.HY.id, apiKey), fredFetch(SERIES.D10.id, apiKey),
      fredFetch(SERIES.D1.id, apiKey), fredFetch(SERIES.TIPS.id, apiKey),
    ]);
    const slopeRaw = joinAndDiff(d10Raw, d1Raw);

    async function addMedian(rawSeries){
      const worker = new Worker(workerURL);
      const medPromise = new Promise((resolve, reject) => {
        worker.onmessage = (e) => { worker.terminate(); resolve(e.data.medians); };
        worker.onerror   = (e) => { worker.terminate(); reject(e.message || 'Worker error'); };
      });
      worker.postMessage({ series: rawSeries, windowYears: 10 });
      const medians = await medPromise;
      const seriesShow = filterShowWindow(rawSeries);
      const idxStart = rawSeries.findIndex(p => p.t === seriesShow[0]?.t);
      const medShow = (idxStart >= 0)
        ? medians.slice(idxStart, idxStart + seriesShow.length).map((m, i) => ({ x: seriesShow[i].t, y: m }))
        : [];
      const lineShow = seriesShow.map(p => ({ x: p.t, y: p.v }));
      return { lineShow, medShow };
    }

    const [hy, slope, tips] = await Promise.all([ addMedian(hyRaw), addMedian(slopeRaw), addMedian(tipsRaw) ]);

    if (!charts){
      charts = {
        hy:    makeChart(document.getElementById('chartHY'),    'HY Spread'),
        slope: makeChart(document.getElementById('chartSlope'), '10y – 1y'),
        tips:  makeChart(document.getElementById('chartTIPS'),  '10y TIPS'),
      };
    }
    function setDatasets(chart, pack){ chart.data.datasets[0].data = pack.lineShow; chart.data.datasets[1].data = pack.medShow; chart.update(); }
    setDatasets(charts.hy, hy); setDatasets(charts.slope, slope); setDatasets(charts.tips, tips);
    setStatus('Loaded. Tip: tap Refresh anytime.');
  } catch (err){
    console.error(err);
    setStatus('Load Failed: ' + (err?.message || String(err)), true);
    alert('Load Failed:\n' + (err?.message || String(err)));
  }
}

window.addEventListener('DOMContentLoaded', () => {
  if (!apiInput.value) setStatus('Enter your FRED API key and press Save key, then Refresh.');
  else bootstrap(false);
});
</script>
</body>
</html>
